개요
=====
종단간 암호화(end to end encryption), 즉 클라이언트가 메세지를 전송할 때 먼저 암호화를 해서 보내고, 받는 사람은 수신 이후에 복호화하여 대화가 중간에 노출되지 않는 기법을 그룹 채팅에 적용해본 서버와 클라이언트 프로그램입니다.   
정보보안에 관심이 생겨 공부를 하던 중 책으로 읽은 이론을 실제로 활용해보는 공부의 필요성을 느껴 시작한 프로젝트입니다.   
https://blog.naver.com/cloudewdev/223947748413 << 클라이언트가 작동하는 모습   
https://blog.naver.com/cloudewdev/223932455696 << 이 프로그램에서 사용한 종단간 암호화의 수학적 배경   

실행 방법
====
서버는 데비안 리눅스 기반의 라즈비안 OS에서 만들어졌고, 실행하는데는 개방할 포트를 인자로 받으며 openssl 라이브러리가 필요합니다.   
rapidjson과 gmp는 폴더 내에 포함되어 있어 따로 설치할 필요는 없습니다.   
클라이언트는 닷넷 런타임 9 기반의 C#으로 만들었습니다.   
bin/debug/net9.0 내부의 ChatClient.bat 파일을 수정하여 자신이 사용할 서버의 ip 주소와 포트 번호로 바꾼 다음 실행하면 됩니다.   

작동 프로토콜
===

클라이언트 - 서버 세션
---
1. 클라이언트 A는 서버와 연결한 직후, 서버에게 자신의 디피헬만 숫자를 담은 메세지를 보낸다.
2. 서버는 A의 공유 숫자를 받고, A와의 통신에 사용할 숫자를 답장으로 보낸다
3. A는 답장이 올 때까지 일정한 간격을 두고 메세지 전송을 반복하다가, 답장을 받으면 공유 비밀을 바탕으로 서버와의 1:1 세션에 사용할 대칭키를 만들어낸다.

클라이언트 - 클라이언트 암호화 세션
---
1. 서버는 새로운 사람이 들어오면 이를 기존 대화 참가자들에게 알린다. 예시를 들기 위해 A 혼자 있는 상태에서 B가 접속했다고 가정하자.
2. A는 B가 들어왔다는 메세지를 서버와의 암호화 세션으로 전송받고, B에게 자신의 공유 숫자를 보낸다.
3. 서버와의 연결이 끝난 다음 B는 공유 숫자를 받는다.
 3-1. B는 Handshake state machine의 상태가 idle인걸 확인하고 자신의 핸드셰이크 요청에 대한 답장이 아니라 다른 사람이 보낸 핸드셰이크 요청을 받았음을 파악한다.
 3-2. B는 자신의 공유 숫자를 A에게 답장한다.
4. A는 Handshake state machine의 상태가 waiting for rcv임을 확인하고 다른사람이 보낸 핸드셰이크 요청을 받은게 아니라 자신의 핸드셰이크 요청에 대한 답장을 받았음을 파악한다.
5. 서로는 이제 각자의 숫자를 공유했고, 이로부터 공유 비밀이 만들어진다.
 5-1. 만약 방금 핸드셰이크한 상대의 Sender Key를 내가 모른다면, Sender Key 교환으로 넘어간다.
 5-2. 알고 있다면, 방금 한 핸드셰이크는 Double-Ratchet이 작동하며 발생한 핸드셰이크이므로 종료한다.

번외로, 만약 위 과정에서 지금 키를 교환하는 사람이 아닌, 다른 사람의 키 교환 요쳥이 들어오면 무시한다.
그리고 요청을 보내는 측은 자신의 요청이 무시될 가능성이 있으므로, 답장이 올 때까지 일정한 간격을 두고 반복해서 요청을 보낸다.

클라이언트 - 클라이언트 Sender Key 교환
---
1. 서버는 새로운 사람이 들어오거나 누군가가 나가면 이를 기존 대화 참가자들에게 알린다. 위와 마찬가지로 A와 B를 가정하자.
2. 새로운 사람이 들어온 경우, 일단 위의 과정을 통해 1:1로 대칭키를 공유한다. 누군가 나간 경우 바로 Sender Key 교환으로 넘어가야 하지만, 이후 프로토콜을 구현하는 난이도가 너무 어려워 이 프로그램에선 다루지 않는다.
3. A가 디피 헬만 키 교환에 대한 답장을 받고 B의 Sender Key가 없음을 확인했으므로 B에게 자신의 Sender Key를 전송한다. 이 때, 방금 공유한 대칭키를 통해 Sender Key를 암호화해서 보낸다.
4. B는 위 과정와 같은 원리로 Sender Key 교환에 대한 상태를 저장하는 상태 머신을 통해 A에게 답장으로 자신의 Sender Key를 암호화해서 보낸다.
5. 교환 끝.

위 과정에서도 마찬가지로 다른 사람의 요청은 무시하고, 요청할 땐 답장이 올 때까지 반복해서 전송한다.

어려웠던 점과 해결방법
===
지금까지는 프로토콜이 무엇인지 사전적 정의로만 알았다가, 이번 프로젝트를 통해 문외한인 상태로 프로토콜을 설계하려다 보니 키 교환 과정을 조율하는 것이 가장 어려웠습니다.   
이는 상태 머신 패턴을 통해 핸드셰이크 형식의 프로토콜을 설계하여 해결할 수 있었습니다.   
또한 처음에는 클라이언트 역시 C++로 작성했는데, 윈도우 환경에서 비표준 라이브러리를 적용하는 것이 너무 까다로워서 C#으로 언어를 교체하였습니다.

배운 점
===
C# 환경에서의 비동기 처리를 다뤄본 적이 없었기에, 이에 대한 경험이 인상깊게 남았습니다.   
컴퓨터 측면에서의 최적화나 성능 측면에서는 어느정도 한계가 있다는 단점도 있지만, 멀티스레딩보다 개발자 친화적이라 생산성 높게 코드를 작성할 수 있었습니다.  
또한, 이론으로만 배웠던 경쟁 조건, 데드락, 바쁜 대기 문제 등을 이 프로그램 내부에서 직접 겪어보고 해결하며 병렬 처리를 안정적으로 운용하려면 어떻게 구조를 짜야 할지에 대한 감을 잡을 수 있었습니다.     

그 다음으로는 프로토콜의 정의와 개념에 대해 확실하게 알게 되었습니다.   
프로토콜을 설명할 때는 흔히 통신하는 절차라고 설명하는데, 위에서 암호화 세션을 만들고 키를 교환하는 '절차'를 만들어보며 아하! 하는 순간이 찾아왔습니다.   

아쉬운 점
===

처음 목표는 상용 E2EE 메신저 등에서도 쓰이는 Double Ratchet을 구현해보려고 했으나, 클라이언트들이 대화 도중 동시에 정보를 교환하게 만드는 프로토콜을 설계하는 것이 너무 어려워 결국 구현하지 못한 점이 아쉽습니다.   
그러나 상태 머신을 두 개로 나눈 등 Double Ratchet을 염두에 두고 만든 프로그램이기 때문에, 추가 공부를 통해 추후 추가할 수 있으리라 생각합니다.
그리고 개발 초창기에는 객체지향적 설계를 염두에 두고 열심히 객체를 나눴지만, 상태 머신을 추가할때쯤부터 해서 Sender, Reciever, 두 개의 상태 머신, 이렇게 4개의 객체가 너무 거대해진 느낌이 들어 객체지향에 대한 공부도 필요하다는 생각이 들었습니다.
